> **运行时数据区域**
>
![java虚拟机运行时数据区](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1496398859055&di=1374077773d3bb3f5a03988b0455eaea&imgtype=0&src=http%3A%2F%2Fimage.lxway.com%2Fupload%2Fb%2Fd8%2Fbd8dddc76a17810a9c1ce408d533b9e8_thumb.png)

#### 程序计数器

　　程序计数器 （ ProgramCounterRegister）是一块较小的内存空间 ，它可以看作是当前线程所执行的字节码的行号指示器 。在虚拟机的概念模型里 （仅是概念模型 ，各种虚拟机可能会通过一些更高效的方式去实现 ） ，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令 ，分支 、循环 、跳转 、异常处理 、线程恢复等基础功能都需要依赖这个计数器来完成 。   
　　由于 Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的 ，在任何一个确定的时刻 ，一个处理器 （对于多核处理器来说是一个内核 ）都只会执行一条线程中的指令 。因此 ，为了线程切换后能恢复到正确的执行位置 ，每条线程都需要有一个独立的程序计数器 ，各条线程之间计数器互不影响 ，独立存储 ，我们称这类内存区域为 “线程私有 ”的内存 。   
　　如果线程正在执行的是一个 Java方法 ，这个计数器记录的是正在执行的虚拟机字节码指令的地址 ；如果正在执行的是Native方法 ，这个计数器值则为空 （ Undefined ） 。此内存区域是唯一一个在 Java虚拟机规范中没有规定任何在 Java虚拟机规范中没有规定任何 OutOfMemoryError情况的区域 。

#### Java虚拟机栈

- 线程私有，生命周期和线程相同
- 虚拟机栈描述的是Java方法执行的内存模型 ：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表 、操作数栈 、动态链接 、方法出口等信息 。每一个方法从调用直至执行完成的过程 ，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程 。
- 局部变量表存放了编译期可知的各种基本数据类型、对象引用
- 栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中

#### 本地方法栈

　　本地方法栈 （ NativeMethodStack ）与虚拟机栈所发挥的作用是非常相似的 ，它们之间的区别不过是虚拟机栈为虚拟机执行 Java方法 （也就是字节码 ）服务 ，而本地方法栈则为虚拟机使用到的 Native方法服务 。

### Java堆

- 线程共享，虚拟机启动时创建
- 存放对象实例，GC堆
	- 这一点在 Java虚拟机规范中的描述是 ：所有的对象实例以及数组都要在堆上分配，但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟 ，栈上分配 、标量替换优化技术将会导致一些微妙的变化发生 ，所有的对象都分配在堆上也渐渐变得不是那么 “绝对 ”了 。
- 从内存回收的角度来看 ，由于现在收集器基本都采用分代收集算法 ，所以 Java 堆中还可以细分为 ：新生代和老年代 ；再细致一点的有 Eden 空间 、 FromSurvivor 空间 、 ToSurvivor 空间等 。

#### 方法区

　　方法区 （MethodArea ）与 Java堆一样 ，是各个线程共享的内存区域 ，它用于 **存储** 已被虚拟机加载的 **类信息 (类的版本 、字段 、方法 、接口等描述信息外)、常量 、静态变量 、即时编译器编译后的代码等数据** 。虽然 Java虚拟机规范把方法区描述为堆的一个逻辑部分 ，但是它却有一个别名叫做 NonHeap （非堆 ） ，目的应该是与 Java堆区分开来 。

##### 运行时常量池

　　运行时常量池 （ RuntimeConstantPool ）是方法区的一部分 。Class文件中除了有类的版本 、字段 、方法 、接口等描述信息外 ，还有一项信息是常量池 （ConstantPoolTable ） ，用于存放编译期生成的各种字面量和符号引用 ，这部分内容将在类加载后进入方法区的运行时常量池中存放 。   
　　运行时常量池相对于 Class文件常量池的另外一个重要特征是具备动态性 ， Java语言并不要求常量一定只有编译期才能产生 ，也就是并非预置入 Class文件中常量池的内容才能进入方法区运行时常量池 ，运行期间也可能将新的常量放入池中 ，这种特性被开发人员利用得比较多的便是String类的 intern()方法 。
